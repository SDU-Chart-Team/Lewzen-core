#include <string>
#include <vector>
#include <sstream>
#include <memory>
#include <iostream>
#include <fstream>
#include <regex>
#include <set>
#include <iomanip>
#include <filesystem>
#include "../../../json.hpp"

std::string out_dir = "..";
std::string base_dir = "../..";
std::string json_dir = "../../../.attr_def";

using json = nlohmann::json;
namespace fs = std::filesystem;

#define is_uppercase(c) (c <= 'Z' && c >= 'A')
#define is_lowercase(c) (c <= 'z' && c >= 'a')
#define is_legal(c) (is_uppercase(c) || is_lowercase(c) || c == '_')
#define to_uppercase(c) ((char)(is_uppercase(c) ? c : ('A' + c - 'a')))
#define to_lowercase(c) ((char)(is_lowercase(c) ? c : ('a' + c - 'A')))
#define to_bcase(c, b) ((char)(b ? to_uppercase(c) : to_lowercase(c)))
// DOM style to snake style
const std::string dom_to_snake(const std::string &dom, bool uppercase = false) {
    std::string snake;
    for (int i = 0; i < dom.size(); i++) {
        if (dom[i] == '-') {
            snake.push_back('_');
        } else if (is_uppercase(dom[i])) {
            if (i == 0 || (dom[i-1] != '-' && !is_uppercase(dom[i-1]))) snake.push_back('_');
            snake.push_back(to_bcase(dom[i], uppercase));
        } else snake.push_back(to_bcase(dom[i], uppercase));
    }
    return snake;
}
// DOM style to pascal style
const std::string dom_to_pascal(const std::string &dom) {
    std::string pascal;
    bool uppercase = true;
    for (int i = 0; i < dom.size(); i++) {
        if (dom[i] == '-') {
            uppercase = true;
        } else if (is_uppercase(dom[i])) {
            uppercase = true;
            pascal.push_back(to_bcase(dom[i], uppercase));
            uppercase = false;
        } else if (is_lowercase(dom[i])) {
            pascal.push_back(to_bcase(dom[i], uppercase));
            uppercase = false;
        } else {
            pascal.push_back(dom[i]);
            uppercase = true;
        }
    }
    return pascal;
}

const std::string AttributeHPP(const std::vector<std::string> &tags) {
    std::stringstream ss;
    ss << "#ifndef __LZ_ATTR__" << std::endl;
    ss << "#define __LZ_ATTR__" << std::endl;
    ss << "#include <string>" << std::endl;
    ss << "#include <memory>" << std::endl;
    ss << "#include <iostream>" << std::endl;
    ss << "#include \"../utils.h\"" << std::endl;
    ss << "" << std::endl;
    ss << "namespace Lewzen {" << std::endl;
    ss << "    /**" << std::endl;
    ss << "    * An attribute for SVG. (Unimplemented)" << std::endl;
    ss << "    */" << std::endl;
    ss << "    class Attribute {" << std::endl;
    ss << "    private:" << std::endl;
    ss << "        std::function<const std::string()> _commit;" << std::endl;
    ss << "        std::function<const std::string()> _getter;" << std::endl;
    ss << "        std::function<void(const std::string &)> _setter;" << std::endl;
    ss << "        std::function<void(const std::string &)> _on_assign = [](const std::string &last){};" << std::endl;
    ss << "        std::function<void()> _on_bind_func = [](){};" << std::endl;
    ss << "        std::function<void()> _on_bind_ptr = [](){};" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Empty constructor of Attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        Attribute()  {}" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Constructor of Attribute, with binding with getter and setter." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param getter getter function" << std::endl;
    ss << "        * @param setter setter function" << std::endl;
    ss << "        */" << std::endl;
    ss << "        Attribute(std::function<const std::string()> getter, std::function<void(const std::string &)> setter): _getter(getter), _setter(setter) {}" << std::endl;
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Return attribute string, from getter." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @return attribute string." << std::endl;
    ss << "        */" << std::endl;
    ss << "        const std::string get() const {" << std::endl;
    ss << "            if (!_getter) return STR_NULL;" << std::endl;
    ss << "            return _getter();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Return attribute string to be committed." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @return attribute string." << std::endl;
    ss << "        */" << std::endl;
    ss << "        const std::string get_commit()  const {" << std::endl;
    ss << "            if (!_commit) return STR_NULL;" << std::endl;
    ss << "            return _commit();" << std::endl;
    ss << "        }" << std::endl;
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set attribute from value, conver to string and call setter. This will break value binding with bind_func and bind_ptr." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param attr attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void set(const T &attr) { _LZ_WARNING(\"Calling Attribute.set, but no implementation.\") }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set attribute from value, conver to string and call setter.  This will break value binding with bind_func and bind_ptr." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param attr attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        Attribute &operator=(const T &attr) { _LZ_WARNING(\"Calling Attribute.operator=, but no implementation.\") return *this; }" << std::endl;
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a function. This will break value binding with bind_ptr." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_func binding function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void bind(std::function<const T> bind_func) { _LZ_WARNING(\"Calling Attribute.bind, but no implementation.\") }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a function. This will break value binding with bind_func." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_ptr binding pointer." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void bind(const std::weak_ptr<T> &bind_ptr) { _LZ_WARNING(\"Calling Attribute.bind, but no implementation.\") }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a function. This will break value binding with bind_ptr." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_func binding function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        Attribute &operator[](std::function<const T> bind_func) {" << std::endl;
    ss << "            bind(bind_func);" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a function. This will break value binding with bind_func." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_ptr binding pointer." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        Attribute &operator[](const std::weak_ptr<T> &bind_ptr){" << std::endl;
    ss << "            bind(bind_ptr);" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "    }" << std::endl;
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Commit binding or value by setter." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void commit() {" << std::endl;
    ss << "            if (!_setter || !_commit) return;" << std::endl;
    ss << "            _setter(_commit());" << std::endl;
    ss << "        }" << std::endl;
    ss << "" << std::endl;
    ss << "    /// Callback" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set callback for assignment operation." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param on_assign callback function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_assign(std::function<void(const std::string &)> on_assign) { _on_assign = on_assign; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Remove callback for assignment operation." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_assign() { _on_assign = [](const std::string &last){}; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set callback for binding function operation." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param on_bind_func callback function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_func(std::function<void()> on_bind_func) { _on_bind_func = on_bind_func; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Remove callback for binding function operation." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_func() { _on_bind_func = [](){}; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set callback for binding pointer operation." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param on_bind_ptr callback function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_ptr(std::function<void()> on_bind_ptr) { _on_bind_ptr = on_bind_ptr; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Remove callback for binding pointer operation." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_ptr() { _on_bind_ptr = [](){}; }" << std::endl;
    ss << "    };" << std::endl;
    ss << "}" << std::endl;

    fs::path p(out_dir);
    fs::path base(base_dir);
    auto ip = fs::relative(p, base).generic_string();
    ss << std::endl;
    for (auto &tag : tags) {
        ss << "#include \"" << ip << "/attr_" << tag <<".hpp\"" << std::endl;
    }

    ss << "#include \"" << ip << "/attr_constant.hpp\"" << std::endl;
    ss << "#include \"" << ip << "/attr_tuple.hpp\"" << std::endl;
    ss << "#include \"" << ip << "/attr_enumerate.hpp\"" << std::endl;
    ss << "#endif" << std::endl;
    return ss.str();
}

const std::string ConstantHPP() {
    std::stringstream ss;
    ss << "#ifndef __LZ_ATTR_CONSTANT__" << std::endl;
    ss << "#define __LZ_ATTR_CONSTANT__" << std::endl;
    ss << "#include <sstream>" << std::endl;
    ss << "#include \"../attr.hpp\"" << std::endl;
    ss << "" << std::endl;
    ss << "namespace Lewzen {" << std::endl;
    ss << "    template<char const *const_val>" << std::endl;
    ss << "    class AttrConstant {" << std::endl;
    ss << "    private:" << std::endl;
    ss << "        std::function<const std::string()> _commit;" << std::endl;
    ss << "        std::function<const std::string()> _getter;" << std::endl;
    ss << "        std::function<void(const std::string &)> _setter;" << std::endl;
    ss << "        std::string _const_val = const_val;" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Empty constructor of Constant." << std::endl;
    ss << "        */" << std::endl;
    ss << "        AttrConstant() {}" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Constructor of Constant, with binding with getter and setter." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param getter getter function" << std::endl;
    ss << "        * @param setter setter function" << std::endl;
    ss << "        */" << std::endl;
    ss << "        AttrConstant(std::function<const std::string()> getter, std::function<void(const std::string &)> setter): _getter(getter), _setter(setter) {}" << std::endl;
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set getter of Constant this attribute." << std::endl;
    ss << "        * @param getter getter function" << std::endl;
    ss << "        */" << std::endl;
    ss << "        void set_getter(std::function<const std::string()> getter) {" << std::endl;
    ss << "            _getter = getter;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set setter of Constant this attribute." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param setter setter function" << std::endl;
    ss << "        */" << std::endl;
    ss << "        void set_setter(std::function<void(const std::string &)> setter) {" << std::endl;
    ss << "            _setter = setter;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Return attribute string, from getter." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @return attribute string." << std::endl;
    ss << "        */" << std::endl;
    ss << "        const std::string get() const {" << std::endl;
    ss << "            if (!_getter) return STR_NULL;" << std::endl;
    ss << "            return _getter();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Return attribute string to be committed." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @return attribute string." << std::endl;
    ss << "        */" << std::endl;
    ss << "        const std::string get_commit() const {" << std::endl;
    ss << "            if (!_commit) return STR_NULL;" << std::endl;
    ss << "            return _commit();   " << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Commit binding or value by setter." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void commit() {" << std::endl;
    ss << "            if (!_setter || !_commit) return;" << std::endl;
    ss << "            _setter(_commit());" << std::endl;
    ss << "        }" << std::endl;
    ss << "" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set attribute from value, conver to string. This will break value binding with bind_func and bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param attr attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void set(const T &attr)  {" << std::endl;
    ss << "            _setter(STR_NULL);" << std::endl;
    ss << "            _LZ_WARNING(\"Calling AttrConstant.set with no implementation. Reset value.\")" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set attribute from value, conver to string.  This will break value binding with bind_func and bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param attr attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        AttrConstant &operator=(const T &attr)  {" << std::endl;
    ss << "            _setter(STR_NULL);" << std::endl;
    ss << "            _LZ_WARNING(\"Calling AttrConstant.set with no implementation. Reset value.\")" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a function. This will break value binding with bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_func binding function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void bind(std::function<const T()>bind_func)  {" << std::endl;
    ss << "            _setter(STR_NULL);" << std::endl;
    ss << "            _LZ_WARNING(\"Calling AttrConstant.set with no implementation. Reset value.\")" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a function. This will break value binding with bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_func binding function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        AttrConstant &operator[](std::function<const T()>bind_func) {" << std::endl;
    ss << "            _setter(STR_NULL);" << std::endl;
    ss << "            _LZ_WARNING(\"Calling AttrConstant.set with no implementation. Reset value.\")" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a pointer. This will break value binding with bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_ptr binding pointer." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void bind(const std::weak_ptr<T> &bind_ptr) {" << std::endl;
    ss << "            _setter(STR_NULL);" << std::endl;
    ss << "            _LZ_WARNING(\"Calling AttrConstant.set with no implementation. Reset value.\")" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a pointer. This will break value binding with bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_ptr binding pointer." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        AttrConstant &operator[](const std::weak_ptr<T> &bind_ptr) {" << std::endl;
    ss << "            _setter(STR_NULL);" << std::endl;
    ss << "            _LZ_WARNING(\"Calling AttrConstant.set with no implementation. Reset value.\")" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "    " << std::endl;
    ss << "    private:" << std::endl;
    ss << "        std::string _con_val_legal_string;" << std::endl;
    ss << "        const std::string _from_con_val_legal_string() {" << std::endl;
    ss << "            return legal_string_to_string(_con_val_legal_string);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        std::function<const std::string()> _bind_func_legal_string;" << std::endl;
    ss << "        const std::string _from_bind_func_legal_string() {" << std::endl;
    ss << "            return legal_string_to_string(_bind_func_legal_string());" << std::endl;
    ss << "        }" << std::endl;
    ss << "        std::weak_ptr<std::string> _bind_ptr_legal_string;" << std::endl;
    ss << "        const std::string _from_bind_ptr_legal_string() {" << std::endl;
    ss << "            if (auto sp = _bind_ptr_legal_string.lock()) return legal_string_to_string(*sp);" << std::endl;
    ss << "            else return STR_NULL;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Convert legal string to string of Constant." << std::endl;
    ss << "        */" << std::endl;
    ss << "        std::string legal_string_to_string(const std::string &attr) {" << std::endl;
    ss << "            if (!is_legal_string(attr)) {" << std::endl;
    ss << "                _LZ_WARNING(\"Illegal string when converting \\\"\" << attr << \"\\\" to \" << _const_val << \".\")" << std::endl;
    ss << "                return STR_NULL;" << std::endl;
    ss << "            } else {" << std::endl;
    ss << "                return attr;" << std::endl;
    ss << "            }" << std::endl;
    ss << "        }" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set attribute from legal string, conver to string. This will break value binding with bind_func and bind_ptr." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param attr legal string attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void set(const std::string &attr) {" << std::endl;
    ss << "            _con_val_legal_string = attr;" << std::endl;
    ss << "            auto _last = get_commit();" << std::endl;
    ss << "            _commit = std::bind(&AttrConstant::_from_con_val_legal_string, this);" << std::endl;
    ss << "            _on_assign(_last);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set attribute from legal string, conver to string.  This will break value binding with bind_func and bind_ptr." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param attr legal string attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        AttrConstant &operator=(const std::string &attr) {" << std::endl;
    ss << "            _con_val_legal_string = attr;" << std::endl;
    ss << "            auto _last = get_commit();" << std::endl;
    ss << "            _commit = std::bind(&AttrConstant::_from_con_val_legal_string, this);" << std::endl;
    ss << "            _on_assign(_last);" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set attribute from legal string, conver to string. This will break value binding with bind_func and bind_ptr." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param attr legal string attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void set(const char * attr) {" << std::endl;
    ss << "            set(std::string(attr));" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set attribute from legal string, conver to string.  This will break value binding with bind_func and bind_ptr." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param attr legal string attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        AttrConstant &operator=(const char * attr) {" << std::endl;
    ss << "            operator=(std::string(attr));" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a legal string function. This will break value binding with bind_ptr." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_func binding function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void bind(std::function<const std::string()> bind_func) {" << std::endl;
    ss << "            _bind_func_legal_string = bind_func;" << std::endl;
    ss << "            _commit = std::bind(&AttrConstant::_from_bind_func_legal_string, this);" << std::endl;
    ss << "            _on_bind_func();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a legal string function. This will break value binding with bind_ptr." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_func binding function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        AttrConstant &operator[](std::function<const std::string()> bind_func) {" << std::endl;
    ss << "            _bind_func_legal_string = bind_func;" << std::endl;
    ss << "            _commit = std::bind(&AttrConstant::_from_bind_func_legal_string, this);" << std::endl;
    ss << "            _on_bind_func();" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a legal string pointer. This will break value binding with bind_func." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_ptr binding pointer." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void bind(const std::weak_ptr<std::string> &bind_ptr) {" << std::endl;
    ss << "            _bind_ptr_legal_string = bind_ptr;" << std::endl;
    ss << "            _commit = std::bind(&AttrConstant::_from_bind_ptr_legal_string, this);" << std::endl;
    ss << "            _on_bind_ptr();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a legal string pointer. This will break value binding with bind_func." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_ptr binding pointer." << std::endl;
    ss << "        */" << std::endl;
    ss << "        AttrConstant &operator[](const std::weak_ptr<std::string> &bind_ptr) {" << std::endl;
    ss << "            _bind_ptr_legal_string = bind_ptr;" << std::endl;
    ss << "            _commit = std::bind(&AttrConstant::_from_bind_ptr_legal_string, this);" << std::endl;
    ss << "            _on_bind_ptr();" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Check if a string is legal as a Constant attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        bool is_legal_string(const std::string &attr) {" << std::endl;
    ss << "            return attr == _const_val;" << std::endl;
    ss << "        }" << std::endl;
    ss << "" << std::endl;
    ss << "        /// Callback" << std::endl;
    ss << "        private:" << std::endl;
    ss << "            std::function<void(const std::string &)> _on_assign = [](const std::string &last){};" << std::endl;
    ss << "            std::function<void()> _on_bind_func = [](){};" << std::endl;
    ss << "            std::function<void()> _on_bind_ptr = [](){};" << std::endl;
    ss << "        public:" << std::endl;
    ss << "            /**" << std::endl;
    ss << "            * Set callback for assignment operation." << std::endl;
    ss << "            *" << std::endl;
    ss << "            * @param on_assign callback function." << std::endl;
    ss << "            */" << std::endl;
    ss << "            void callback_assign(std::function<void(const std::string &)> on_assign) { _on_assign = on_assign; }" << std::endl;
    ss << "            /**" << std::endl;
    ss << "            * Remove callback for assignment operation." << std::endl;
    ss << "            */" << std::endl;
    ss << "            void callback_assign() { _on_assign = [](const std::string &last){}; }" << std::endl;
    ss << "            /**" << std::endl;
    ss << "            * Set callback for binding function operation." << std::endl;
    ss << "            *" << std::endl;
    ss << "            * @param on_bind_func callback function." << std::endl;
    ss << "            */" << std::endl;
    ss << "            void callback_bind_func(std::function<void()> on_bind_func) { _on_bind_func = on_bind_func; }" << std::endl;
    ss << "            /**" << std::endl;
    ss << "            * Remove callback for binding function operation." << std::endl;
    ss << "            */" << std::endl;
    ss << "            void callback_bind_func() { _on_bind_func = [](){}; }" << std::endl;
    ss << "            /**" << std::endl;
    ss << "            * Set callback for binding pointer operation." << std::endl;
    ss << "            *" << std::endl;
    ss << "            * @param on_bind_ptr callback function." << std::endl;
    ss << "            */" << std::endl;
    ss << "            void callback_bind_ptr(std::function<void()> on_bind_ptr) { _on_bind_ptr = on_bind_ptr; }" << std::endl;
    ss << "            /**" << std::endl;
    ss << "            * Remove callback for binding pointer operation." << std::endl;
    ss << "            */" << std::endl;
    ss << "            void callback_bind_ptr() { _on_bind_ptr = [](){}; }" << std::endl;
    ss << "    };" << std::endl;
    ss << "" << std::endl;
    std::ifstream file(json_dir + "/constant");
    std::set<std::string> cset;
    if (file.is_open()) {
        std::string line;
        while (std::getline(file, line)) {
            if (cset.count(line)) continue;
            cset.insert(line);
            ss << "    static const char _const_" << dom_to_pascal(line) << "[] = \"" << line << "\";" << std::endl;
            ss << "    using AttrConst" << dom_to_pascal(line) << " = AttrConstant<_const_" << dom_to_pascal(line) << ">;" << std::endl;
        }
        file.close();
    }
    ss << "}" << std::endl;
    ss << "#endif" << std::endl;
    return ss.str();
}

const std::string EnumerateHPP(const std::vector<std::string> &tags) {
    std::stringstream ss;
    ss << "#ifndef __LZ_ATTR_ENUMERATE__" << std::endl;
    ss << "#define __LZ_ATTR_ENUMERATE__" << std::endl;
    ss << "#ifdef debug" << std::endl;
    ss << "#undef debug" << std::endl;
    ss << "#define __debug" << std::endl;
    ss << "#endif" << std::endl;
    ss << "#include <tuple>" << std::endl;
    ss << "#include \"../attr.hpp\"" << std::endl;
    ss << "" << std::endl;
    ss << "namespace Lewzen {" << std::endl;
    ss << "    template<typename... Ts>" << std::endl;
    ss << "    class AttrEnumerate {" << std::endl;
    ss << "    private:" << std::endl;
    ss << "        std::tuple<Ts...> _tuple;" << std::endl;
    ss << "        std::string _attr;" << std::endl;
    ss << "    private:" << std::endl;
    ss << "        const std::string _commit() const {" << std::endl;
    ss << "            return __commit<0, Ts...>();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<std::size_t i, typename L>" << std::endl;
    ss << "        const std::string __commit() const {" << std::endl;
    ss << "            auto u = std::get<i>(_tuple);" << std::endl;
    ss << "            return __commit_impl(u);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        const std::string __commit() const {" << std::endl;
    ss << "            auto u = std::get<i>(_tuple);" << std::endl;
    ss << "            auto &s = __commit_impl(u);" << std::endl;
    ss << "            if (s != STR_NULL) return s;" << std::endl;
    ss << "            return __commit<i + 1, S, R...>();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename I>" << std::endl;
    ss << "        const std::string __commit_impl(I &u) const {" << std::endl;
    ss << "            #ifdef __debug" << std::endl;
    ss << "            std::cout  << \"Warning: \" << \"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Enumerate, which only supports SVG attributes.\"<< std::endl;" << std::endl;
    ss << "            #endif" << std::endl;
    ss << "            return STR_NULL;" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
        ss << "        const std::string __commit_impl(Attr" << dom_to_pascal(tag) << " &u) const {" << std::endl;
        ss << "            return u.get_commit();" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << "        std::function<const std::string()> _getter;" << std::endl;
    ss << "        std::function<void(const std::string &)> _setter;" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Empty Constructor of Enumerate." << std::endl;
    ss << "        */" << std::endl;
    ss << "        AttrEnumerate() {}" << std::endl;
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Constructor of Enumerate" << std::endl;
    ss << "        */" << std::endl;
    ss << "        AttrEnumerate(std::function<const std::string()> getter, std::function<void(const std::string &)> setter): _getter(getter), _setter(setter) {" << std::endl;
    ss << "            _Enumerate<0, Ts...>(_getter, _setter);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<std::size_t i, typename L>" << std::endl;
    ss << "        void _Enumerate(std::function<const std::string()> getter, std::function<void(const std::string &)> setter) {" << std::endl;
    ss << "            auto u = std::get<i>(_tuple);" << std::endl;
    ss << "            _EnumerateImpl(u, getter, setter);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        void _Enumerate(std::function<const std::string()> getter, std::function<void(const std::string &)> setter) {" << std::endl;
    ss << "            auto u = std::get<i>(_tuple);" << std::endl;
    ss << "            _EnumerateImpl(u, getter, setter);" << std::endl;
    ss << "            _Enumerate<i + 1, S, R...>(getter, setter);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename I>" << std::endl;
    ss << "        void _EnumerateImpl(I &u, std::function<const std::string()> getter, std::function<void(const std::string &)> setter) {" << std::endl;
    ss << "            #ifdef __debug" << std::endl;
    ss << "            std::cout  << \"Warning: \" << \"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Enumerate, which only supports SVG attributes.\"<< std::endl;" << std::endl;
    ss << "            #endif" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
        ss << "        void _EnumerateImpl(Attr" << dom_to_pascal(tag) << " &u, std::function<const std::string()> getter, std::function<void(const std::string &)> setter) {" << std::endl;
        ss << "            u.set_getter(getter), u.set_setter(setter);" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set getter of Integer this attribute." << std::endl;
    ss << "        * @param getter getter function" << std::endl;
    ss << "        */" << std::endl;
    ss << "        void set_getter(std::function<const std::string()> getter) {" << std::endl;
    ss << "            _getter = getter;" << std::endl;
    ss << "            _Enumerate<0, Ts...>(getter, _setter);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set setter of Integer this attribute." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param setter setter function" << std::endl;
    ss << "        */" << std::endl;
    ss << "        void set_setter(std::function<void(const std::string &)> setter) {" << std::endl;
    ss << "            _setter = setter;" << std::endl;
    ss << "            _Enumerate<0, Ts...>(_getter, setter);" << std::endl;
    ss << "        }" << std::endl;
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Return attribute string, from getter." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @return attribute string." << std::endl;
    ss << "        */" << std::endl;
    ss << "        const std::string get() const {" << std::endl;
    ss << "            if (!_getter) return STR_NULL;" << std::endl;
    ss << "            return _getter();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Return attribute string to be committed." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @return attribute string." << std::endl;
    ss << "        */" << std::endl;
    ss << "        const std::string get_commit() const {" << std::endl;
    ss << "            return _commit();   " << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Commit binding or value by setter." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void commit() {" << std::endl;
    ss << "            if (!_setter) return;" << std::endl;
    ss << "            _setter(_commit());" << std::endl;
    ss << "        }" << std::endl;
    ss << "" << std::endl;
    ss << "    // Set" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set attribute from value, conver to string. This will break value binding with bind_func and bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param attr attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void set(const T &attr) {" << std::endl;
    ss << "            auto _last = get_commit();" << std::endl;
    ss << "            _set<T, 0, Ts...>(attr);" << std::endl;
    ss << "            _on_assign(_last);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, std::size_t i, typename L>" << std::endl;
    ss << "        void _set(const T &attr) {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _set_impl(attr, u);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        void _set(const T &attr) {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _set_impl(attr, u);" << std::endl;
    ss << "            _set<T, i + 1, S, R...>(attr);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, typename I>" << std::endl;
    ss << "        void _set_impl(const T &attr, const I &u) {" << std::endl;
    ss << "            #ifdef __debug" << std::endl;
    ss << "            std::cout  << \"Warning: \" << \"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Enumerate, which only supports SVG attributes.\"<< std::endl;" << std::endl;
    ss << "            #endif" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
         ss << "        template<typename T>" << std::endl;
        ss << "        void _set_impl(const T &attr, Attr" << dom_to_pascal(tag) << " &u) {" << std::endl;
        ss << "            u.set(attr);" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << "    " << std::endl;
    ss << "    // Operator1" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set attribute from value, conver to string.  This will break value binding with bind_func and bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param attr attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        AttrEnumerate<Ts...> &operator=(const T &attr) {" << std::endl;
    ss << "            auto _last = get_commit();" << std::endl;
    ss << "            _op1<T, 0, Ts...>(attr);" << std::endl;
    ss << "            _on_assign(_last);" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, std::size_t i, typename L>" << std::endl;
    ss << "        void _op1(const T &attr) {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _op1_impl(attr, u);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        void _op1(const T &attr) {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _op1_impl(attr, u);" << std::endl;
    ss << "            _op1<T, i + 1, S, R...>(attr);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, typename I>" << std::endl;
    ss << "        void _op1_impl(const T &attr, const I &u) {" << std::endl;
    ss << "            #ifdef __debug" << std::endl;
    ss << "            std::cout  << \"Warning: \" << \"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Enumerate, which only supports SVG attributes.\"<< std::endl;" << std::endl;
    ss << "            #endif" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
         ss << "        template<typename T>" << std::endl;
        ss << "        void _op1_impl(const T &attr, Attr" << dom_to_pascal(tag) << " &u) {" << std::endl;
        ss << "            u = attr;" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << "" << std::endl;
    ss << "    // Bind function" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a function. This will break value binding with bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_func binding function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void bind(std::function<const T()>bind_func) {" << std::endl;
    ss << "            _bind1<T, 0, Ts...>(bind_func);" << std::endl;
    ss << "            _on_bind_func();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void bind(const T(*bind_func)()) {" << std::endl;
    ss << "            std::function<const T()> _bind_func = bind_func;" << std::endl;
    ss << "            bind(_bind_func);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void __bind(std::function<T()>bind_func) {" << std::endl;
    ss << "            _bind1<T, 0, Ts...>(bind_func);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void bind(T bind_func) {" << std::endl;
    ss << "            auto p = lambda_to_function(bind_func);" << std::endl;
    ss << "            __bind(p);" << std::endl;
    ss << "            _on_bind_func();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, std::size_t i, typename L>" << std::endl;
    ss << "        void _bind1(std::function<const T()>bind_func) {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _bind1_impl(bind_func, u);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        void _bind1(std::function<const T()>bind_func) {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _bind1_impl(bind_func, u);" << std::endl;
    ss << "            _bind1<T, i + 1, S, R...>(bind_func);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, typename I>" << std::endl;
    ss << "        void _bind1_impl(std::function<const T()>bind_func, const I &u) {" << std::endl;
    ss << "            #ifdef __debug" << std::endl;
    ss << "            std::cout  << \"Warning: \" << \"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Enumerate, which only supports SVG attributes.\"<< std::endl;" << std::endl;
    ss << "            #endif" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
         ss << "        template<typename T>" << std::endl;
        ss << "        void _bind1_impl(std::function<const T()>bind_func, Attr" << dom_to_pascal(tag) << " &u) {" << std::endl;
        ss << "            u.bind(bind_func);" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << "" << std::endl;
    ss << "    // Operator2" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a function. This will break value binding with bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_func binding function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        AttrEnumerate<Ts...> &operator[](std::function<const T()>bind_func) {" << std::endl;
    ss << "            _op2<T, 0, Ts...>(bind_func);" << std::endl;
    ss << "            _on_bind_func();" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        AttrEnumerate<Ts...> &operator[](const T(*bind_func)()) {" << std::endl;
    ss << "            std::function<const T()> _bind_func = bind_func;" << std::endl;
    ss << "            operator[](_bind_func);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void __op2(std::function<T()>bind_func) {" << std::endl;
    ss << "            _op2<T, 0, Ts...>(bind_func);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        AttrEnumerate<Ts...> &operator[](T bind_func) {" << std::endl;
    ss << "            auto p = lambda_to_function(bind_func);" << std::endl;
    ss << "            __op2(p);" << std::endl;
    ss << "            _on_bind_func();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, std::size_t i, typename L>" << std::endl;
    ss << "        void _op2(std::function<const T()>bind_func) {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _op2_impl(bind_func, u);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        void _op2(std::function<const T()>bind_func) {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _op2_impl(bind_func, u);" << std::endl;
    ss << "            _op2<T, i + 1, S, R...>(bind_func);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, typename I>" << std::endl;
    ss << "        void _op2_impl(std::function<const T()>bind_func, const I &u) {" << std::endl;
    ss << "            #ifdef __debug" << std::endl;
    ss << "            std::cout  << \"Warning: \" << \"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Enumerate, which only supports SVG attributes.\"<< std::endl;" << std::endl;
    ss << "            #endif" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
         ss << "        template<typename T>" << std::endl;
        ss << "        void _op2_impl(std::function<const T()>bind_func, Attr" << dom_to_pascal(tag) << " &u) {" << std::endl;
        ss << "            u[bind_func];" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << "" << std::endl;
    ss << "    // Bind pointer" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a pointer. This will break value binding with bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_ptr binding pointer." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void bind(const std::weak_ptr<T> &bind_ptr) {" << std::endl;
    ss << "            _bind2<T, 0, Ts...>(bind_ptr);" << std::endl;
    ss << "            _on_bind_ptr();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, std::size_t i, typename L>" << std::endl;
    ss << "        void _bind2(const std::weak_ptr<T> &bind_ptr) {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _bind2_impl(bind_ptr, u);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        void _bind2(const std::weak_ptr<T> &bind_ptr) {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _bind2_impl(bind_ptr, u);" << std::endl;
    ss << "            _bind2<T, i + 1, S, R...>(bind_ptr);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, typename I>" << std::endl;
    ss << "        void _bind2_impl(const std::weak_ptr<T> &bind_ptr, const I &u) {" << std::endl;
    ss << "            #ifdef __debug" << std::endl;
    ss << "            std::cout  << \"Warning: \" << \"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Enumerate, which only supports SVG attributes.\"<< std::endl;" << std::endl;
    ss << "            #endif" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
         ss << "        template<typename T>" << std::endl;
        ss << "        void _bind2_impl(const std::weak_ptr<T> &bind_ptr, Attr" << dom_to_pascal(tag) << " &u) {" << std::endl;
        ss << "            u.bind(bind_ptr);" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << "" << std::endl;
    ss << "    // Operator3" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a pointer. This will break value binding with bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_ptr binding pointer." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        AttrEnumerate<Ts...> &operator[](const std::weak_ptr<T> &bind_ptr) {" << std::endl;
    ss << "            _op3<T, 0, Ts...>(bind_ptr);" << std::endl;
    ss << "            _on_bind_ptr();" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, std::size_t i, typename L>" << std::endl;
    ss << "        void _op3(const std::weak_ptr<T> &bind_ptr) {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _op3_impl(bind_ptr, u);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        void _op3(const std::weak_ptr<T> &bind_ptr) {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _op3_impl(bind_ptr, u);" << std::endl;
    ss << "            _op3<T, i + 1, S, R...>(bind_ptr);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename T, typename I>" << std::endl;
    ss << "        void _op3_impl(const std::weak_ptr<T> &bind_ptr, const I &u) {" << std::endl;
    ss << "            #ifdef __debug" << std::endl;
    ss << "            std::cout  << \"Warning: \" << \"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Enumerate, which only supports SVG attributes.\"<< std::endl;" << std::endl;
    ss << "            #endif" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
         ss << "        template<typename T>" << std::endl;
        ss << "        void _op3_impl(const std::weak_ptr<T> &bind_ptr, Attr" << dom_to_pascal(tag) << " &u) {" << std::endl;
        ss << "            u[bind_ptr];" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << std::endl;
    ss << "    /// Callback" << std::endl;
    ss << "    private:" << std::endl;
    ss << "        std::function<void(const std::string &)> _on_assign = [](const std::string &last){};" << std::endl;
    ss << "        std::function<void()> _on_bind_func = [](){};" << std::endl;
    ss << "        std::function<void()> _on_bind_ptr = [](){};" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set callback for assignment operation." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param on_assign callback function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_assign(std::function<void(const std::string &)> on_assign) { _on_assign = on_assign; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Remove callback for assignment operation." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_assign() { _on_assign = [](const std::string &last){}; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set callback for binding function operation." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param on_bind_func callback function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_func(std::function<void()> on_bind_func) { _on_bind_func = on_bind_func; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Remove callback for binding function operation." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_func() { _on_bind_func = [](){}; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set callback for binding pointer operation." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param on_bind_ptr callback function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_ptr(std::function<void()> on_bind_ptr) { _on_bind_ptr = on_bind_ptr; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Remove callback for binding pointer operation." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_ptr() { _on_bind_ptr = [](){}; }" << std::endl;
    ss << "    };" << std::endl;
    ss << "}" << std::endl;
    ss << "#ifdef __debug" << std::endl;
    ss << "#undef __debug" << std::endl;
    ss << "#define debug" << std::endl;
    ss << "#endif" << std::endl;
    ss << "#endif" << std::endl;
    return ss.str();
}

const std::string TupleHPP(const std::vector<std::string> &tags) {
    std::stringstream ss;
    ss << "#ifndef __LZ_ATTR_TUPLE__" << std::endl;
    ss << "#define __LZ_ATTR_TUPLE__" << std::endl;
    ss << "#include <array>" << std::endl;
    ss << "#include <tuple>" << std::endl;
    ss << "#include <sstream>" << std::endl;
    ss << "#include \"../attr.hpp\"" << std::endl;
    ss << "" << std::endl;
    ss << "namespace Lewzen {" << std::endl;
    ss << "    template<typename... Ts>" << std::endl;
    ss << "    class AttrTuple {" << std::endl;
    ss << "    private:" << std::endl;
    ss << "        std::tuple<Ts...> _tuple;" << std::endl;
    ss << "        std::array<std::string, sizeof...(Ts)> _attrs;" << std::endl;
    ss << "        std::array<std::function<const std::string()>, sizeof...(Ts)> _getts;" << std::endl;
    ss << "        std::array<std::function<void(const std::string &)>, sizeof...(Ts)> _setts;" << std::endl;
    ss << "        std::string _seperator;" << std::endl;
    ss << "    private:" << std::endl;
    ss << "        const std::string _commit() const {" << std::endl;
    ss << "        __commit<0, Ts...>();" << std::endl;
    ss << "        std::stringstream ss;" << std::endl;
    ss << "            for (int i = 0; i < sizeof...(Ts); i++) {" << std::endl;
    ss << "                ss << _attrs[i];" << std::endl;
    ss << "                if (i < sizeof...(Ts) - 1) ss << _seperator;" << std::endl;
    ss << "            }" << std::endl;
    ss << "            return ss.str();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<std::size_t i, typename L>" << std::endl;
    ss << "        void __commit() const {" << std::endl;
    ss << "            auto u = std::get<i>(_tuple);" << std::endl;
    ss << "            __commit_impl(u);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        void __commit() const {" << std::endl;
    ss << "            auto u = std::get<i>(_tuple);" << std::endl;
    ss << "            __commit_impl(u);" << std::endl;
    ss << "            __commit<i + 1, S, R...>();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename I>" << std::endl;
    ss << "        void __commit_impl(I &u) const {" << std::endl;
    ss << "            _LZ_WARNING(\"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Tuple, which only supports SVG attributes.\");" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
        ss << "        void __commit_impl(Attr" << dom_to_pascal(tag) << " &u) const {" << std::endl;
        ss << "            u.commit();" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << "        std::function<const std::string()> _getter;" << std::endl;
    ss << "        std::function<void(const std::string &)> _setter;" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Empty Constructor of Tuple." << std::endl;
    ss << "        */" << std::endl;
    ss << "        AttrTuple() {}" << std::endl;
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Constructor of Tuple" << std::endl;
    ss << "        */" << std::endl;
    ss << "        AttrTuple(std::function<const std::string()> getter, std::function<void(const std::string &)> setter, std::string seperator = \" \"): _getter(getter), _setter(setter), _seperator(seperator) {" << std::endl;
    ss << "            _Tuple<0, Ts...>();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<std::size_t i, typename L>" << std::endl;
    ss << "        void _Tuple() {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _getts[i] = [this](){return _attrs[i];}, _setts[i] = [this](const std::string &attr){_attrs[i] = attr;};" << std::endl;
    ss << "            _TupleImpl(u, _getts[i], _setts[i]);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        void _Tuple() {" << std::endl;
    ss << "            auto &u = std::get<i>(_tuple);" << std::endl;
    ss << "            _getts[i] = [this](){return _attrs[i];}, _setts[i] = [this](const std::string &attr){_attrs[i] = attr;};" << std::endl;
    ss << "            _TupleImpl(u, _getts[i], _setts[i]);" << std::endl;
    ss << "            _Tuple<i + 1, S, R...>();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename I>" << std::endl;
    ss << "        void _TupleImpl(I &u, std::function<const std::string()> getter, std::function<void(const std::string &)> setter) {" << std::endl;
    ss << "            _LZ_WARNING(\"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Tuple, which only supports SVG attributes.\");" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
        ss << "        void _TupleImpl(Attr" << dom_to_pascal(tag) << " &u, std::function<const std::string()> getter, std::function<void(const std::string &)> setter) {" << std::endl;
        ss << "            u.set_getter(getter), u.set_setter(setter);" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set getter of Integer this attribute." << std::endl;
    ss << "        * @param getter getter function" << std::endl;
    ss << "        */" << std::endl;
    ss << "        void set_getter(std::function<const std::string()> getter) {" << std::endl;
    ss << "            _getter = getter;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set setter of Integer this attribute." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param setter setter function" << std::endl;
    ss << "        */" << std::endl;
    ss << "        void set_setter(std::function<void(const std::string &)> setter) {" << std::endl;
    ss << "            _setter = setter;" << std::endl;
    ss << "        }" << std::endl;
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Return attribute string, from getter." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @return attribute string." << std::endl;
    ss << "        */" << std::endl;
    ss << "        const std::string get() const {" << std::endl;
    ss << "            if (!_getter) return STR_NULL;" << std::endl;
    ss << "            return _getter();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Return attribute string to be committed." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @return attribute string." << std::endl;
    ss << "        */" << std::endl;
    ss << "        const std::string get_commit() const {" << std::endl;
    ss << "            return _commit();   " << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Commit binding or value by setter." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void commit() {" << std::endl;
    ss << "            if (!_setter) return;" << std::endl;
    ss << "            _setter(_commit());" << std::endl;
    ss << "        }" << std::endl;
    ss << "" << std::endl;
    ss << "    // Array-like operations" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        template<int i>" << std::endl;
    ss << "        decltype(std::get<i>(_tuple)) &at() {" << std::endl;
    ss << "            return std::get<i>(_tuple);" << std::endl;
    ss << "        }" << std::endl;
    ss << "" << std::endl;
    ss << "    /// Callback" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set callback for assignment operation." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param on_assign callback function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_assign(std::function<void(const std::string &)> on_assign) { __callback_assign<0, Ts...>(on_assign); }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Remove callback for assignment operation." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_assign() { __callback_assign<0, Ts...>([](const std::string &last){}); }" << std::endl;
    ss << "        template<std::size_t i, typename L>" << std::endl;
    ss << "        void __callback_assign(std::function<void(const std::string &)> on_assign) const {" << std::endl;
    ss << "            auto u = std::get<i>(_tuple);" << std::endl;
    ss << "            __callback_assign_impl(u, on_assign);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        void __callback_assign(std::function<void(const std::string &)> on_assign) const {" << std::endl;
    ss << "            auto u = std::get<i>(_tuple);" << std::endl;
    ss << "            __callback_assign_impl(u, on_assign);" << std::endl;
    ss << "            __callback_assign<i + 1, S, R...>(on_assign);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename I>" << std::endl;
    ss << "        void __callback_assign_impl(I &u, std::function<void(const std::string &)> on_assign) const {" << std::endl;
    ss << "            _LZ_WARNING(\"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Tuple, which only supports SVG attributes.\");" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
        ss << "        void __callback_assign_impl(Attr" << dom_to_pascal(tag) << " &u, std::function<void(const std::string &)> on_assign) const {" << std::endl;
        ss << "            u.callback_assign(on_assign);" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << "        /**" << std::endl;
    ss << "        * Set callback for binding function operation." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param on_bind_func callback function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_func(std::function<void()> on_bind_func) { __callback_bind_func<0, Ts...>(on_bind_func); }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Remove callback for binding function operation." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_func() { __callback_bind_func<0, Ts...>([](){}); }" << std::endl;
    ss << "        template<std::size_t i, typename L>" << std::endl;
    ss << "        void __callback_bind_func(std::function<void()> on_bind_func) const {" << std::endl;
    ss << "            auto u = std::get<i>(_tuple);" << std::endl;
    ss << "            __callback_bind_func_impl(u, on_bind_func);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        void __callback_bind_func(std::function<void()> on_bind_func) const {" << std::endl;
    ss << "            auto u = std::get<i>(_tuple);" << std::endl;
    ss << "            __callback_bind_func_impl(u, on_bind_func);" << std::endl;
    ss << "            __callback_bind_func<i + 1, S, R...>(on_bind_func);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename I>" << std::endl;
    ss << "        void __callback_bind_func_impl(I &u, std::function<void()> on_bind_func) const {" << std::endl;
    ss << "            _LZ_WARNING(\"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Tuple, which only supports SVG attributes.\");" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
        ss << "        void __callback_bind_func_impl(Attr" << dom_to_pascal(tag) << " &u, std::function<void()> on_bind_func) const {" << std::endl;
        ss << "            u.callback_bind_func(on_bind_func);" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << "        /**" << std::endl;
    ss << "        * Set callback for binding pointer operation." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param on_bind_ptr callback function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_ptr(std::function<void()> on_bind_ptr) { __callback_bind_ptr<0, Ts...>(on_bind_ptr); }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Remove callback for binding pointer operation." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_ptr() { __callback_bind_ptr<0, Ts...>([](){}); }" << std::endl;
    ss << "        template<std::size_t i, typename L>" << std::endl;
    ss << "        void __callback_bind_ptr(std::function<void()> on_bind_ptr) const {" << std::endl;
    ss << "            auto u = std::get<i>(_tuple);" << std::endl;
    ss << "            __callback_bind_ptr_impl(u, on_bind_ptr);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<std::size_t i, typename F, typename S, typename ...R>" << std::endl;
    ss << "        void __callback_bind_ptr(std::function<void()> on_bind_ptr) const {" << std::endl;
    ss << "            auto u = std::get<i>(_tuple);" << std::endl;
    ss << "            __callback_bind_ptr_impl(u, on_bind_ptr);" << std::endl;
    ss << "            __callback_bind_ptr<i + 1, S, R...>(on_bind_ptr);" << std::endl;
    ss << "        }" << std::endl;
    ss << "        template<typename I>" << std::endl;
    ss << "        void __callback_bind_ptr_impl(I &u, std::function<void()> on_bind_ptr) const {" << std::endl;
    ss << "            _LZ_WARNING(\"Found unsupported ctype \\\"\" << typeid(u).name() << \"\\\" in Tuple, which only supports SVG attributes.\");" << std::endl;
    ss << "        }" << std::endl;
    for (auto &tag : tags) {
        ss << "        void __callback_bind_ptr_impl(Attr" << dom_to_pascal(tag) << " &u, std::function<void()> on_bind_ptr) const {" << std::endl;
        ss << "            u.callback_bind_ptr(on_bind_ptr);" << std::endl;
        ss << "        }" << std::endl;
    }
    ss << "    };" << std::endl;
    ss << "}" << std::endl;
    ss << "#endif" << std::endl;
    return ss.str();
}

class Func {
private:
    std::string _cls, _declaration, _comment, _implementation;
    std::string _indentation, _indentation2;
public:
    Func(std::string cls, std::string declaration, std::string comment, std::string implementation, int indentation) {
        _cls = cls, _declaration = declaration, _comment = comment, _implementation = implementation;
        for (int i = 0; i < indentation; i++) _indentation.push_back(' ');
        for (int i = 0; i < indentation - 4; i++) _indentation2.push_back(' ');
        _comment = std::regex_replace(_comment, std::regex("\n"), "\n" + _indentation + "* ");
        _implementation = _indentation + std::regex_replace(_implementation, std::regex("\n"), "\n" + _indentation);
    }
    const std::string in_hpp_file() {
        std::stringstream ss;
        ss << _indentation << "/**" << std::endl;
        ss << _indentation << "* " << _comment << std::endl;
        ss << _indentation << "*/" << std::endl;
        ss << _indentation << std::regex_replace(_declaration, std::regex(";"), "") << " {" << std::endl;
        ss << _implementation << std::endl;
        ss << _indentation << "}" << std::endl;
        return ss.str();
    }
};

class Accept {
private:
    std::string _type, _comment;
    std::string _ctype, _cname, _to_string;
    std::vector<Func> _funcs;
public:
    Accept(std::string typ, std::string comment,
               std::string ctype, std::string cname, std::string to_string,
               std::vector<Func> funcs): _type(typ), _comment(comment), _ctype(ctype), _cname(cname), _to_string(to_string), _funcs(funcs) {
        _comment = std::regex_replace(_comment, std::regex("\n"), "\n        * ");
        _to_string = "        " + std::regex_replace(_to_string, std::regex("\n"), "\n        ");
    }
    const std::string in_hpp_file() {
        std::stringstream ss;
        ss << "    private:" << std::endl;
        ss << "        " << _ctype << " _con_val_" << std::regex_replace(_cname, std::regex("\\s"), "_") << ";" << std::endl;
        ss << "        const std::string _from_con_val_" << std::regex_replace(_cname, std::regex("\\s"), "_") << "() {" << std::endl;
        ss << "            return " << std::regex_replace(_cname, std::regex("\\s"), "_") << "_to_string(_con_val_" << std::regex_replace(_cname, std::regex("\\s"), "_") << ");" << std::endl;
        ss << "        }" << std::endl;
        ss << "        std::function<const " << _ctype << "()> _bind_func_" << std::regex_replace(_cname, std::regex("\\s"), "_") << ";" << std::endl;
        ss << "        const std::string _from_bind_func_" << std::regex_replace(_cname, std::regex("\\s"), "_") << "() {" << std::endl;
        ss << "            return " << std::regex_replace(_cname, std::regex("\\s"), "_") << "_to_string(_bind_func_" << std::regex_replace(_cname, std::regex("\\s"), "_") << "());" << std::endl;
        ss << "        }" << std::endl;
        ss << "        std::weak_ptr<" << _ctype << "> _bind_ptr_" << std::regex_replace(_cname, std::regex("\\s"), "_") << ";" << std::endl;
        ss << "        const std::string _from_bind_ptr_" << std::regex_replace(_cname, std::regex("\\s"), "_") << "() {" << std::endl;
        ss << "            if (auto sp = _bind_ptr_" << std::regex_replace(_cname, std::regex("\\s"), "_") << ".lock()) return " << std::regex_replace(_cname, std::regex("\\s"), "_") << "_to_string(*sp);" << std::endl;
        ss << "            else return STR_NULL;" << std::endl;
        ss << "        }" << std::endl;
        ss << "        /**" << std::endl;
        ss << "        * Convert " << _cname << " to string of Attr" << dom_to_pascal(_type) << "." << std::endl;
        ss << "        */" << std::endl;
        ss << "        static std::string " << std::regex_replace(_cname, std::regex("\\s"), "_") << "_to_string(const " << _ctype << " &attr) {" << std::endl;
        ss << "    " << _to_string << std::endl;
        ss << "        }" << std::endl;
        ss << "    public:" << std::endl;
        ss << "        /**" << std::endl;
        ss << "        * Set attribute from " << _cname << ", conver to string. This will break value binding with bind_func and bind_ptr." << std::endl;
        ss << "        *" << std::endl;
        ss << "        * @param attr " << _cname << " attribute." << std::endl;
        ss << "        */" << std::endl;
        ss << "        void set(const " << _ctype << " &attr) {" << std::endl;
        ss << "            _con_val_" << std::regex_replace(_cname, std::regex("\\s"), "_") << " = attr;" << std::endl;
        ss << "            auto _last = get_commit();" << std::endl;
        ss << "            _commit = std::bind(&Attr" << dom_to_pascal(_type) << "::_from_con_val_" << std::regex_replace(_cname, std::regex("\\s"), "_") << ", this);" << std::endl;
        ss << "            _on_assign(_last);" << std::endl;
        ss << "        }" << std::endl;
        ss << "        /**" << std::endl;
        ss << "        * Set attribute from " << _cname << ", conver to string.  This will break value binding with bind_func and bind_ptr." << std::endl;
        ss << "        *" << std::endl;
        ss << "        * @param attr " << _cname << " attribute." << std::endl;
        ss << "        */" << std::endl;
        ss << "        Attr" << dom_to_pascal(_type) << " &operator=(const " << _ctype << " &attr) {" << std::endl;
        ss << "            _con_val_" << std::regex_replace(_cname, std::regex("\\s"), "_") << " = attr;" << std::endl;
        ss << "            auto _last = get_commit();" << std::endl;
        ss << "            _commit = std::bind(&Attr" << dom_to_pascal(_type) << "::_from_con_val_" << std::regex_replace(_cname, std::regex("\\s"), "_") << ", this);" << std::endl;
        ss << "            _on_assign(_last);" << std::endl;
        ss << "            return *this;" << std::endl;
        ss << "        }" << std::endl;
        if (_ctype == "std::string") { // consider char *
            ss << "        /**" << std::endl;
            ss << "        * Set attribute from " << _cname << ", conver to string. This will break value binding with bind_func and bind_ptr." << std::endl;
            ss << "        *" << std::endl;
            ss << "        * @param attr " << _cname << " attribute." << std::endl;
            ss << "        */" << std::endl;
            ss << "        void set(const char * attr) {" << std::endl;
            ss << "            set(std::string(attr));" << std::endl;
            ss << "        }" << std::endl;
            ss << "        /**" << std::endl;
            ss << "        * Set attribute from " << _cname << ", conver to string.  This will break value binding with bind_func and bind_ptr." << std::endl;
            ss << "        *" << std::endl;
            ss << "        * @param attr " << _cname << " attribute." << std::endl;
            ss << "        */" << std::endl;
            ss << "        Attr" << dom_to_pascal(_type) << " &operator=(const char * attr) {" << std::endl;
            ss << "            operator=(std::string(attr));" << std::endl;
            ss << "            return *this;" << std::endl;
            ss << "        }" << std::endl;
        }
        ss << "        /**" << std::endl;
        ss << "        * Bind attribute to a " << _cname << " function. This will break value binding with bind_ptr." << std::endl;
        ss << "        *" << std::endl;
        ss << "        * @param bind_func binding function." << std::endl;
        ss << "        */" << std::endl;
        ss << "        void bind(std::function<const " << _ctype << "()> bind_func) {" << std::endl;
        ss << "            _bind_func_" << std::regex_replace(_cname, std::regex("\\s"), "_") << " = bind_func;" << std::endl;
        ss << "            _commit = std::bind(&Attr" << dom_to_pascal(_type) << "::_from_bind_func_" << std::regex_replace(_cname, std::regex("\\s"), "_") << ", this);" << std::endl;
        ss << "            _on_bind_func();" << std::endl;
        ss << "        }" << std::endl;
        ss << "        /**" << std::endl;
        ss << "        * Bind attribute to a " << _cname << " function. This will break value binding with bind_ptr." << std::endl;
        ss << "        *" << std::endl;
        ss << "        * @param bind_func binding function." << std::endl;
        ss << "        */" << std::endl;
        ss << "        Attr" << dom_to_pascal(_type) << " &operator[](std::function<const " << _ctype << "()> bind_func) {" << std::endl;
        ss << "            _bind_func_" << std::regex_replace(_cname, std::regex("\\s"), "_") << " = bind_func;" << std::endl;
        ss << "            _commit = std::bind(&Attr" << dom_to_pascal(_type) << "::_from_bind_func_" << std::regex_replace(_cname, std::regex("\\s"), "_") << ", this);" << std::endl;
        ss << "            _on_bind_func();" << std::endl;
        ss << "            return *this;" << std::endl;
        ss << "        }" << std::endl;
        ss << "        /**" << std::endl;
        ss << "        * Bind attribute to a " << _cname << " pointer. This will break value binding with bind_func." << std::endl;
        ss << "        *" << std::endl;
        ss << "        * @param bind_ptr binding pointer." << std::endl;
        ss << "        */" << std::endl;
        ss << "        void bind(const std::weak_ptr<" << _ctype << "> &bind_ptr) {" << std::endl;
        ss << "            _bind_ptr_" << std::regex_replace(_cname, std::regex("\\s"), "_") << " = bind_ptr;" << std::endl;
        ss << "            _commit = std::bind(&Attr" << dom_to_pascal(_type) << "::_from_bind_ptr_" << std::regex_replace(_cname, std::regex("\\s"), "_") << ", this);" << std::endl;
        ss << "            _on_bind_ptr();" << std::endl;
        ss << "        }" << std::endl;
        ss << "        /**" << std::endl;
        ss << "        * Bind attribute to a " << _cname << " pointer. This will break value binding with bind_func." << std::endl;
        ss << "        *" << std::endl;
        ss << "        * @param bind_ptr binding pointer." << std::endl;
        ss << "        */" << std::endl;
        ss << "        Attr" << dom_to_pascal(_type) << " &operator[](const std::weak_ptr<" << _ctype << "> &bind_ptr) {" << std::endl;
        ss << "            _bind_ptr_" << std::regex_replace(_cname, std::regex("\\s"), "_") << " = bind_ptr;" << std::endl;
        ss << "            _commit = std::bind(&Attr" << dom_to_pascal(_type) << "::_from_bind_ptr_" << std::regex_replace(_cname, std::regex("\\s"), "_") << ", this);" << std::endl;
        ss << "            _on_bind_ptr();" << std::endl;
        ss << "            return *this;" << std::endl;
        ss << "        }" << std::endl;
        for (auto &f : _funcs) ss << f.in_hpp_file();
        return ss.str();
    }
};

const std::string HPPFile(std::string typ, std::string comment, std::vector<std::string> includes, std::vector<Accept> accepts) {
    std::stringstream ss;
    comment = std::regex_replace(comment, std::regex("\n"), "\n    * ");
    ss << "#ifndef __LZ_ATTR_" << dom_to_snake(typ, true) << "__" << std::endl;
    ss << "#define __LZ_ATTR_" << dom_to_snake(typ, true) << "__" << std::endl;
    ss << "#include <functional>" << std::endl;
    ss << "#include <string>" << std::endl;
    ss << "#include <memory>" << std::endl;
    ss << "#include <iostream>" << std::endl;
    for (auto &inc : includes) ss << "#include <" << inc << ">" << std::endl;
    ss << "#include \"../../utils.h\"" << std::endl;
    ss << "" << std::endl;
    ss << "namespace Lewzen {" << std::endl;
    ss << "    /**" << std::endl;
    ss << "    * " << comment << std::endl;
    ss << "    */" << std::endl;
    ss << "    class Attr" << dom_to_pascal(typ) << " {" << std::endl;
    ss << "    private:" << std::endl;
    ss << "        std::function<const std::string()> _commit;" << std::endl;
    ss << "        std::function<const std::string()> _getter;" << std::endl;
    ss << "        std::function<void(const std::string &)> _setter;" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Empty constructor of " << dom_to_pascal(typ) << "." << std::endl;
    ss << "        */" << std::endl;
    ss << "        Attr" << dom_to_pascal(typ) << "() {}" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Constructor of " << dom_to_pascal(typ) << ", with binding with getter and setter." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param getter getter function" << std::endl;
    ss << "        * @param setter setter function" << std::endl;
    ss << "        */" << std::endl;
    ss << "        Attr" << dom_to_pascal(typ) << "(std::function<const std::string()> getter, std::function<void(const std::string &)> setter): _getter(getter), _setter(setter) {}" << std::endl;
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set getter of " << dom_to_pascal(typ) << " this attribute." << std::endl;
    ss << "        * @param getter getter function" << std::endl;
    ss << "        */" << std::endl;
    ss << "        void set_getter(std::function<const std::string()> getter) {" << std::endl;
    ss << "            _getter = getter;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set setter of " << dom_to_pascal(typ) << " this attribute." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param setter setter function" << std::endl;
    ss << "        */" << std::endl;
    ss << "        void set_setter(std::function<void(const std::string &)> setter) {" << std::endl;
    ss << "            _setter = setter;" << std::endl;
    ss << "        }" << std::endl;
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Return attribute string, from getter." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @return attribute string." << std::endl;
    ss << "        */" << std::endl;
    ss << "        const std::string get() const {" << std::endl;
    ss << "            if (!_getter) return STR_NULL;" << std::endl;
    ss << "            return _getter();" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Return attribute string to be committed." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @return attribute string." << std::endl;
    ss << "        */" << std::endl;
    ss << "        const std::string get_commit() const {" << std::endl;
    ss << "            if (!_commit) return STR_NULL;" << std::endl;
    ss << "            return _commit();   " << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Commit binding or value by setter." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void commit() {" << std::endl;
    ss << "            if (!_setter || !_commit) return;" << std::endl;
    ss << "            _setter(_commit());" << std::endl;
    ss << "        }" << std::endl;
    ss << "" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set attribute from value, conver to string. This will break value binding with bind_func and bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param attr attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void set(const T &attr) {" << std::endl;
    ss << "            _setter(STR_NULL);" << std::endl;
    ss << "            _LZ_WARNING(\"Calling Attr" << dom_to_pascal(typ) << ".set with no implementation. Reset value.\")" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set attribute from value, conver to string.  This will break value binding with bind_func and bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param attr attribute." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        Attr" << dom_to_pascal(typ) << " &operator=(const T &attr) {" << std::endl;
    ss << "            _setter(STR_NULL);" << std::endl;
    ss << "            _LZ_WARNING(\"Calling Attr" << dom_to_pascal(typ) << ".set with no implementation. Reset value.\")" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a function. This will break value binding with bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_func binding function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void bind(std::function<const T()>bind_func) {" << std::endl;
    ss << "            _setter(STR_NULL);" << std::endl;
    ss << "            _LZ_WARNING(\"Calling Attr" << dom_to_pascal(typ) << ".bind with no implementation. Reset value.\")" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a function. This will break value binding with bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_func binding function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        Attr" << dom_to_pascal(typ) << " &operator[](std::function<const T()>bind_func) {" << std::endl;
    ss << "            _setter(STR_NULL);" << std::endl;
    ss << "            _LZ_WARNING(\"Calling Attr" << dom_to_pascal(typ) << ".bind with no implementation. Reset value.\")" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a pointer. This will break value binding with bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_ptr binding pointer." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        void bind(const std::weak_ptr<T> &bind_ptr) {" << std::endl;
    ss << "            _setter(STR_NULL);" << std::endl;
    ss << "            _LZ_WARNING(\"Calling Attr" << dom_to_pascal(typ) << ".bind with no implementation. Reset value.\")" << std::endl;
    ss << "        }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Bind attribute to a pointer. This will break value binding with bind_ptr. (This function will reset commit)" << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param bind_ptr binding pointer." << std::endl;
    ss << "        */" << std::endl;
    ss << "        template <typename T>" << std::endl;
    ss << "        Attr" << dom_to_pascal(typ) << " &operator[](const std::weak_ptr<T> &bind_ptr) {" << std::endl;
    ss << "            _setter(STR_NULL);" << std::endl;
    ss << "            _LZ_WARNING(\"Calling Attr" << dom_to_pascal(typ) << ".bind with no implementation. Reset value.\")" << std::endl;
    ss << "            return *this;" << std::endl;
    ss << "        }" << std::endl;
    for (auto &a : accepts) ss << std::endl << a.in_hpp_file();
    ss << std::endl;
    ss << "    /// Callback" << std::endl;
    ss << "    private:" << std::endl;
    ss << "        std::function<void(const std::string &)> _on_assign = [](const std::string &last){};" << std::endl;
    ss << "        std::function<void()> _on_bind_func = [](){};" << std::endl;
    ss << "        std::function<void()> _on_bind_ptr = [](){};" << std::endl;
    ss << "    public:" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set callback for assignment operation." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param on_assign callback function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_assign(std::function<void(const std::string &)> on_assign) { _on_assign = on_assign; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Remove callback for assignment operation." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_assign() { _on_assign = [](const std::string &last){}; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set callback for binding function operation." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param on_bind_func callback function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_func(std::function<void()> on_bind_func) { _on_bind_func = on_bind_func; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Remove callback for binding function operation." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_func() { _on_bind_func = [](){}; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Set callback for binding pointer operation." << std::endl;
    ss << "        *" << std::endl;
    ss << "        * @param on_bind_ptr callback function." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_ptr(std::function<void()> on_bind_ptr) { _on_bind_ptr = on_bind_ptr; }" << std::endl;
    ss << "        /**" << std::endl;
    ss << "        * Remove callback for binding pointer operation." << std::endl;
    ss << "        */" << std::endl;
    ss << "        void callback_bind_ptr() { _on_bind_ptr = [](){}; }" << std::endl;
    ss << "    };" << std::endl;
    ss << "}" << std::endl;
    ss << "#endif" << std::endl;
    return ss.str();
}

const std::string json_to_source(const std::string &path) {
    fs::path p(path);
    if (p.extension() != ".json") return "";
    std::ifstream i(path);
    json j; i >> j;

    std::string typ = j["type"];
    std::string comment =  j["comment"];
    std::vector<std::string> includes;
    for (auto inc: j["includes"]) includes.push_back(inc);
    std::vector<Accept> accepts;

    for (auto a : j["accepts"]) {
        std::vector<Func> funcs;
        for (auto f : a["additional_funcs"]) {
            funcs.push_back(Func("Attr" + dom_to_pascal(typ), f["declaration"], f["comment"], f["implementation"], 8));
        }
        accepts.push_back(Accept(typ, comment, a["ctype"], a["cname"], a["to_string"], funcs));
    }

    std::ofstream o1(out_dir + "/attr_" + typ + ".hpp");
    o1 << HPPFile(typ, comment, includes, accepts);

    std::cout << "done : " << typ << std::endl;
    return typ;
}

const std::string Makefile(const std::vector<std::string> &tags) {
    std::stringstream ss;
    ss << "objects = \\" << std::endl;
    ss << "\tattr_constant.hpp.gch\\" << std::endl;
    ss << "\tattr_tuple.hpp.gch\\" << std::endl;
    ss << "\tattr_enumerate.hpp.gch\\" << std::endl;
    for (int i = 0; i < tags.size(); i++) {
        ss << "\tattr_" << tags[i] << ".hpp.gch";
        if (i < tags.size() - 1) ss << "\\";
        ss << std::endl;
    }
    ss << "cc = g++" << std::endl;
    ss << std::endl;
    ss << ".PHONY: all" << std::endl;
    ss << "all: $(objects)" << std::endl;
    ss << std::endl;
    for (auto &tag : tags) ss << "attr_" << tag << ".hpp.gch: attr_" << tag << ".hpp" << std::endl << "\t$(cc) -c attr_" << tag << ".hpp" << std::endl;
    ss << "attr_constant.hpp.gch: attr_constant.hpp" << std::endl << "\t$(cc) -c attr_constant.hpp" << std::endl;
    ss << "attr_tuple.hpp.gch: attr_tuple.hpp" << std::endl << "\t$(cc) -c attr_tuple.hpp" << std::endl;
    ss << "attr_enumerate.hpp.gch: attr_enumerate.hpp" << std::endl << "\t$(cc) -c attr_enumerate.hpp" << std::endl;
    ss << std::endl;
    ss << ".PHONY: all" << std::endl;
    ss << "clean:" << std::endl;
	ss << "\t-rm $(objects)" << std::endl;
    return ss.str();
}

int main(int argc, char **argv) {
    std::vector<std::string> tags;

    for (const auto &file : fs::directory_iterator(json_dir)) {
        auto tag = json_to_source(file.path());
        if (tag == "") continue;
        tags.push_back(tag);
    }

    std::ofstream o(out_dir + "/attr_tuple.hpp");
    o << TupleHPP(tags);
    std::cout << "done : tuple" << std::endl;
    o = std::ofstream(out_dir + "/attr_enumerate.hpp");
    o << EnumerateHPP(tags);
    std::cout << "done : enumerate" << std::endl;
    o = std::ofstream(out_dir + "/attr_constant.hpp");
    o << ConstantHPP();
    std::cout << "done : constant" << std::endl;
    o = std::ofstream(base_dir + "/attr.hpp");
    o << AttributeHPP(tags);
    std::cout << "done : attr" << std::endl;

    std::ofstream o1(out_dir + "/Makefile");
    o1 << Makefile(tags);
    std::cout << "Makefile done." << std::endl;

    std::cout << "includes.out done." << std::endl;
}

// Tuple
// Enumerate
// Basic Type
    // Plain Text
    // Content Type