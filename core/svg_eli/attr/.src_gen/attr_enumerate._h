#ifndef __LZ_ATTR_TUPLE__
#define __LZ_ATTR_TUPLE__
#include <tuple>
#include "../attr.h"

namespace Lewzen {
    template<typename... Ts>
    class Tuple {
    private:
        std::tuple<Ts...> _tuple;
        std::string _seperator;
    private:
        std::function<const std::string()> _commit;
        std::function<const std::string()> _getter;
        std::function<void(const std::string &)> _setter;
    public:
        /**
        * Empty Constructor of Tuple.
        */
        void Tuple() {}

        /**
        * Constructor of Tuple
        */
        Tuple(std::function<const std::string()> getter, std::function<void(const std::string &)> setter, std::string seperator = ""): _seperator(seperator) {
            _Tuple<0, Ts...>(getter, setter);
        }
        template<std::size_t i, typename L>
        void _Tuple(std::function<const std::string()> getter, std::function<void(const std::string &)> setter) {
            auto u = std::get<i>(_tuple);
            _TupleImpl(u, getter, setter);
        }
        template<std::size_t i, typename F, typename S, typename ...R>
        void _Tuple(std::function<const std::string()> getter, std::function<void(const std::string &)> setter) {
            auto u = std::get<i>(_tuple);
            _TupleImpl(u, getter, setter);
            _Tuple<i + 1, S, R...>(getter, setter);
        }
        template<typename I>
        void _TupleImpl(const I &u, std::function<const std::string()> getter, std::function<void(const std::string &)> setter) {
            _LZ_WARNING("Found unsupported ctype \"" + typeid(u).name() + "\" in Tuple, which only supports SVG attributes.");
        }
        void _TupleImpl(const Number &u, std::function<const std::string()> getter, std::function<void(const std::string &)> setter) {
            u = Number(getter, setter);
        }

        /**
        * Return attribute string, from getter.
        *
        * @return attribute string.
        */
        const std::string get() const {
            return _get<0, Ts...>();
        }
        template<std::size_t i, typename L>
        const std::string _get() const {
            auto u = std::get<i>(_tuple);
            _get_impl(u, getter, setter);
        }
        template<std::size_t i, typename F, typename S, typename ...R>
        const std::string _get() const {
            auto u = std::get<i>(_tuple);
            return _get(u, getter, setter) + _seperator + _Tuple<i + 1, S, R...>(getter, setter);
        }
        template<typename I>
        const std::string _get_impl(const I &u) const {
            _LZ_WARNING("Found unsupported ctype \"" + typeid(u).name() + "\" in Tuple, which only supports SVG attributes.");
            return "";
        }
        const std::string _get_impl(const Number &u) const {
            return u.get();
        }


        /**
        * Return attribute string to be committed.
        *
        * @return attribute string.
        */
        const std::string get_commit() const {

        }


        /**
        * Commit binding or value by setter.
        */
        void commit() {

        }

    // Default write functions
    public:
        template<typename I>
        void _setImpl(const I &u) {}
        void _setImpl(const A &u) {
            u.print();
        }
        template<std::size_t i, typename L>
        void _set() {
            auto u = std::get<i>(_tuple);
            _setImpl(u);
        }
        template<std::size_t i, typename F, typename S, typename ...R>
        void _set() {
            auto u = std::get<i>(_tuple);
            _setImpl(u);
            _set<i + 1, S, R...>();
        }
        void set() {
            _set<0, Ts...>();
        }
    
    // Write for std::pair
    public:

    // Write for std::tuple
    public:

    // Write for std::string
    public:
    };
}
#endif